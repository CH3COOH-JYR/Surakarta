## 第一阶段
#### 规则实现算法
**基本规则判断：** <br/>
  第一，先判断是否是当前选手所在回合。<br/>
  第二，判断是否出界。<br/>
  第三，判断from是不是己方棋子，空白棋和对方棋结束。<br/>
  第四，判断to是什么类型棋子，己方棋子结束，对方棋子旋吃判断，空白棋邻移判断。<br/>
**邻移判断：** <br/>
  判断to与from的x,y各自差值绝对值是否小于等于1。<br/>
**旋吃判断：** <br/>
  应该注意到，旋吃一开始只能向4个方向走，且一旦方向选定，后面的旋转时的坐标转换，走的路径全部确定。要么路上有其他棋子，要么到to所在位置，要么回到from所在位置。<br/>
  首先，在坐标未发生转换之前，碰到棋子就应该返回。<br/>
  其次，坐标发生转换之后，有三种情况返回：第一，到to；第二，到from；第三，路上有棋子。<br/>
  所以只要写4个函数表示向4个方向遍历棋盘，只要有一个方向能到to就行。<br/>



#### AI算法
**算法**  <br/>
 编写一个加分机制<br/>
（1）若这一步能吃子，直接return。<br/>
（2）若这一步不能吃子：<br/>
1.粗略讨论位置，处于中心位置的棋子以及关键交叉位置会加上一个较高的分值，处于角落或者边界上的棋子加上一个较低分值。<br/>
2.更新并遍历棋盘，讨论下一步移子，若reason == SurakartaIllegalMoveReason::LEGAL_CAPTURE_MOVE（实际上是被吃）,分为两种情况，若目前玩家棋子数目>=6个，则加分（棋子数目多时基本上是换子）；否则，减分（不能白送）；<br/>
根据最高分数return best_score。<br/>              


#### 分工
**代码**  该阶段规则判断代码为廖祥宇2023202313完成，AI算法为刘远航2023202275完成。<br/>
**调错完善**  代码调错完善由徐巍威2023202286负责，保证了代码的可运行性，完整性，整洁性。<br/>


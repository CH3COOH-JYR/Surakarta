# 第一阶段报告

## 一、规则实现

### 1.judgemove

* 移动是否超出棋盘边界：将move.from坐标、move.to坐标与boardsize作比较。

* 判断是否操作非棋子的位置：判断move.from棋子颜色是否不是黑色也不是白色。

* 判断是否是合法玩家在操作：将当前玩家与实际玩家比较。

* 判断玩家是否正确移动己方棋子：将move.from的棋子颜色与玩家颜色相比较。

* 判断是否是合法的不吃子移动：移动范围在上下左右、左上、左下、右上、右下八个位置范围内且目标位置不能有棋子。

* 旋吃：我们首先确定起始位置是在哪个环上，为了避免不同环交叉位置的影响，在分类讨论时，我们选取了互不干扰的行或列。旋吃在一个环道上无非只有两条路，即顺时针和逆时针，为了提高代码的可重复性，我们为棋子的信息设置了坐标与移动方向（方向即direction，1代表向左，2代表向右，3代表向上，4代表向下）。在while循环中，只要没碰到目标棋子，循环就会模拟棋子移动遍历，在遇到旋的时候更改棋子位置与移动方向，并且将经过旋的次数times+1。如果遇到了非目标棋子同时非初始位置，就算遇到了障碍，此时flag+1。最后判断是否合法时，就要看times是否大于零，并且flag是否等于0，两项都满足才算合法。

* n!=6的情况：我们用for循环遍历环道的行或列即可实现。

  

### 2.judgeend

* 如果走出非法步，自动结束。

* 只剩一个棋子时，该棋子可以被对手吃，那么游戏结束。

* 未吃子轮数超过设置的最大轮数，再看哪方棋子多。

  

## 二、AI实现

我们一开始用的贪心算法，但发现我们的打分规则并不合理，单单推演两步棋并不能凸显其副作用，所以我们改用了简单的minmax搜索算法。

（还未实现，以下只有思路）

## 三、遇到的问题及解决方法

### 1.规则实现

思路其实并没有问题，只是代码中会有些小的手误写错了。并且在测试时并没有及时去更新助教的改动，没有先删除build再测试导致在这方面消耗很多时间。

### 2.AI实现

打分的规则不完善（minmax搜索最底层给棋盘打分）：参考了一些论文文献，在报告最后标注。

## 四、分工

* 规则实现：王粲然
* AI实现：待定
* 实验报告：王粲然、杨昱文

> 刘璇，陶秋子，赵洪飞，等.计算机博弈苏拉卡尔塔棋的算法研究与改进[J].中文科技期刊数据库(全文版)自然科学,2018,[计算机博弈苏拉卡尔塔棋的算法研究与改进 - 道客巴巴 (doc88.com)](https://www.doc88.com/p-3009165882898.html)

